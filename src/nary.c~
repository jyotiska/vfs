#include<stdio.h>
#include<string.h>
#include<malloc.h>
#include<stdlib.h>

#include "../include/vfs_main.h"
#include "../include/nary.h"

//n-ary tree
/*search
insert
delete
findparent*/


/*struct file_descriptor* search_nary(struct file_descriptor *root,struct file_descriptor *node)
{      
        struct file_descriptor *temp=root,*parent=NULL;
          if(temp->nodeName==node){
              parent=temp;
           }
             temp=temp->left;
         if(temp!=NULL && temp->nodeName==node)
              parent=temp;
        while(temp!=root && temp!=NULL)
        {
               
                if(temp->left!=NULL && temp->left_traversed == 0)
                {       if(temp->left->nodeName==node)
                          parent=temp->left;
                        temp=temp->left;
                       
                }
                else if(temp->sibling!=NULL)
                {        if(temp->sibling->nodeName==node)
                            parent=temp->sibling;
                        temp->left_traversed = 0;
                        temp=temp->sibling;
                       
                }
                else
                {
                        temp->left_traversed = 0;
                        temp=temp->parent;
                        temp->left_traversed = 1;
                }
        }      
      return parent;   
}

*/

void print_ntree(struct ntree *root)
{	
	struct ntree *temp=root;
	printf("----------Current VFS Structure----------\n\n%s",temp->file_name);
	temp=temp->left;
	//printf("\n%s",temp->file_name);
	if(temp!=NULL)
		printf("\nNode - %s Sibling - %s Parent - %s Left - %s",temp->file_name,temp->sibling->file_name,temp->parent->file_name,temp->left->file_name);
	while(temp!=root && temp!=NULL)
	{
		
		if(temp->left!=NULL && temp->left_traversed == 0)
		{
			temp=temp->left;
			printf("\nNode - %s Sibling - %s Parent - %s Left - %s",temp->file_name,temp->sibling->file_name,temp->parent->file_name,temp->left->file_name);
		}
		else if(temp->sibling!=NULL)
		{
			temp->left_traversed = 0;
			temp=temp->sibling;
			printf("\nNode - %s Sibling - %s Parent - %s Left - %s",temp->file_name,temp->sibling->file_name,temp->parent->file_name,temp->left->file_name);
		}
		else
		{
			temp->left_traversed = 0;
			temp=temp->parent;
			temp->left_traversed = 1;
		}
	}	
	printf("\n\n");
}


struct ntree* nary_insert (struct file_descriptor *node, struct ntree *root)
{
	struct ntree *temp=root;
 	int rootcheck = 0;
	int i = 0,pos=0,j=0,y,z;
	int fail_cause=-1;

	char str[100];
  	char new[10][20];
  	char * pch;
   	strcpy(str,node->location_full_path);
  	pch = strtok (str,"/");
  	
	while (pch != NULL)
  	{
    		strcpy(new[i],pch);
		i++;
    		pch = strtok (NULL, "/");
	
  	}
	while(temp)
	{
		

		if(rootcheck == 0)
		{
		
			if(strcmp(temp->file_name,new[j])==0)
			{
				prev=temp;
				temp=temp->left;
                                j++;
			}
			else
			{
				//printf("Wrong path !!!");
				fail_cause = 0;
			}
			rootcheck=1;
		}
		
		
		if(temp!=NULL)
		{
			if(fail_cause==-1 && j!=i && strcmp(temp->file_name,new[j])==0)
			{
				prev=temp;
				temp=temp->left;
				j++;
	
			}
			else
			{
				sib=temp;
				temp=temp->sibling;
			}
		}
	}
	if(fail_cause == -1)
	{
		if(prev->left==NULL)
		{
	//create
			struct ntree *new=(struct ntree*)malloc(sizeof(struct ntree));
			new->left_traversed=0;
			new->parent=prev;
			prev->left=new;
			strcpy(new->file_name,node->file_name);
			new->left=NULL;
			new->sibling=NULL;

			strcpy(new->location_full_path,node->location_full_path);
			new->file_type=node->file_type;
			new->file_size=node->file_size;
			new->location_block_number = node->location_block_number;

		}
		else if(strcmp(prev->file_name,new[i-1])==0)
		{
			struct ntree *new=(struct ntree*)malloc(sizeof(struct ntree));
			new->left_traversed=0;
			new->parent=prev;
			sib->sibling=new;
			strcpy(new->file_name,node->file_name);
			new->left=NULL;
			new->sibling=NULL;

			strcpy(new->location_full_path,node->location_full_path);
			new->file_type=node->file_type;
			new->file_size=node->file_size;
			new->location_block_number = node->location_block_number;
		}
		else
		{
			//printf("\nWrong path !!!\nPATH --- %s \n\n\n",node->location_full_path );
		}
	}
	return root;
}

struct ntree* nary_delete(struct file_descriptor *node,struct ntree *root)
{
	struct ntree *temp=root;
	struct ntree *prev;
	int i = 0,j=0;
	char str[100];
	char new[10][20];
  	char * pch;
	
	int pathcheck = 0;
	printf("\n%s\n",root->file_name);
 
  	strcpy(str,node->location_full_path);

  	pch = strtok (str,"/");
  	while (pch != NULL)
  	{
    		strcpy(new[i],pch);
		i++;
    		pch = strtok (NULL, "/");
  	}
	int num_of_tokens = i;

	int ret_val = 0;
	for(i=0; i<num_of_tokens && temp!=NULL ; i++)
	{
		if(strcmp(new[i],temp->file_name)==0)
		{
			prev=temp;
			//sib=temp->sibling;
			temp=temp->left;
		}
		else
		{
			temp=temp->sibling;
			if(temp==NULL)
			{
				ret_val = -1; //wrong path
				printf("ret_val = %d",ret_val);
			}
			while(temp)
			{
				if(strcmp(new[i],temp->file_name)==0)
				{
					prev=temp;
					//sib=temp->sibling;
					temp=temp->left;
					break;
				}
				else
				{
					temp=temp->sibling;
				}
			}
		}
	}

	if(temp==NULL)
	{
		pathcheck=1;
	}

	struct ntree *prevsib=NULL;

	if(pathcheck==0)
	{

		if(strcmp(node->file_name,temp->file_name)==0)
		{
			
		}
		else
		{
			prevsib=temp;
			temp=temp->sibling;
			if(temp==NULL)
			{
				ret_val = -2; //wrong name
				pathcheck = 1;
			}
			while(temp!=NULL)
			{
				if(strcmp(node->file_name,temp->file_name)==0)
				{
					break;
				}
				else
				{
					prevsib=temp;
					temp=temp->sibling;
				}
			}
		}
	}

	if(pathcheck == 0 )
	{
		if(prevsib!=NULL)
		{
			if(temp->sibling!=NULL)
			{
				prevsib->sibling = temp->sibling;
			}
			else
			{
				prevsib->sibling=temp->left;
			}
		}
		else if(temp->sibling != NULL)
		{
			prev->left=temp->sibling;
		}
		else
		{
			prev->left=temp->left;
		} 
	}
	return root;
}

struct ntree* nary_insert_root()
{
	//struct ntree *node = (struct file_descriptor*)malloc(sizeof(struct file_descriptor));
	struct ntree *root = (struct ntree*)malloc(sizeof(struct ntree));
	root->left_traversed=0;
	strcpy(root->file_name,"bond");
	root->left=NULL;
	root->sibling=NULL;
	root->parent=NULL;

	return root;
}
/*
int main()
{
	struct ntree *root = (struct ntree*)malloc(sizeof(struct ntree));
	root->left_traversed=0;
	strcpy(root->node->file_name,"root");
	root->left=NULL;
	root->sibling=NULL;
	root->parent=NULL;
	
	char fname[20], fpath[100];
	int choice;
	while(1)
	{
		printf("\n1 for Insert, 2 for Delete, 3 for Search and 4 to Exit");
		scanf("%d",&choice);
		if(choice == 1)
		{
			printf("\nEnter file name and path:");
			scanf("%s",fname);
			scanf("%s",fpath);
			insert(fpath,fname,root);
		}
		else if(choice == 2)
		{
			printf("\nEnter file name and path:");
			scanf("%s",fname);
			scanf("%s",fpath);
			delete(fpath,fname,root);
		}
		else if(choice == 3)
		{
			print_ntree(root);
		}
		else if(choice == 4)
			exit(0);
		else
			printf("\nWrong Choice!");
	}
	
/*		
	insert("root/","dir1",root);
	//print_ntree(root);
	
	insert("root/","file1",root);
	//print_ntree(root);

	insert("root/","file2",root);

	insert("root/file1","file3",root);
	insert("root/file1","file4",root);

	//insert("root/file1/file5","file6",root);
        delete("root/file1","file4",root);
    	//delete("root/file1/file5","file6",root);
	print_ntree(root);
	
return 0;

}*/
